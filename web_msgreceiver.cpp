#include "taskdispatch_app.h"#include "web_msgreceiver.h"extern CWebMsgReceiver g_WebMsgReceiverThread;extern CThreadLock g_TaskMapLock;extern stru_MysqlConfig g_mysqladdr;

CWebMsgReceiver::CWebMsgReceiver(){	m_pWebInterface = NULL;	m_pTaskExecute = NULL;	m_pTaskPackageMsg = NULL;}
CWebMsgReceiver::~CWebMsgReceiver(){	;}BOOL CWebMsgReceiver::Prepare(long *pnResult){	m_MysqlOperate.SetMysqlConf(&g_mysqladdr);	return TRUE;}BOOL CWebMsgReceiver::OnMsg(TRawMsg * msg,IMsg * remote_src){	if( MSG_TYPE_WEB_TASK == msg->type )	{		TRACE_LOG("[_Debug]: get the web command !");		strings strsRec;		char* pchar = (char*)msg->_param;		U64 wTaskID;		TaskStatusMsg StatusCheckMsg;						BlacklistTaskMsg BlacklistMsg;//*******************************test*****************************				TRACE_LOG("[_Debug]: get the web command content:%s",pchar);		char buffer[256];		TRawMsg *webMsg;		memset(buffer,0,256);		webMsg = (TRawMsg*)buffer;		webMsg->type = MSG_TYPE_WEB_TASK;		webMsg->len = strlen(pchar);		memcpy(webMsg->_param,pchar,webMsg->len);		if(m_pWebInterface)			m_pWebInterface->SendMsg(webMsg);				divide_string(pchar,strsRec,",");				if(strsRec.size() < 3)			return FALSE;			if( !strcmp(strsRec[0].c_str(),"RULENO") )		{			wTaskID = atol(strsRec[1].c_str());			TRACE_LOG("[_Debug]: the wTaskID is %llu",wTaskID);			if( !strcmp(strsRec[2].c_str(),"CREATE") )			{					memset(&StatusCheckMsg,0,sizeof(TaskStatusMsg));				INIT_MSG_HEADER(&StatusCheckMsg);				StatusCheckMsg.type = MSG_TYPE_CHECK_TASK_STATUS;				StatusCheckMsg.InvokeID = wTaskID;					if( NULL != m_pTaskExecute)				{					TRACE_LOG("[_Debug]: send check task status !");					m_pTaskExecute->SendMsg(&StatusCheckMsg);				}else				{					TRACE_LOG("[_Debug]: the m_pTaskExecute is NULL");				}				return TRUE;			}			else if( !strcmp(strsRec[2].c_str(),"CLOSE") )			{				CloseWebTaskHandle(wTaskID);			}			else			{				TRACE_LOG("[_Debug]: we get a wrong task !");				return FALSE;			}		}		if( !strcmp(strsRec[0].c_str(),"DC_BLACK") )		{			TRawMsg BlackMsg;			INIT_MSG_HEADER(&BlackMsg);			BlackMsg.type = MSG_TYPE_REQUEST_BLACKLIST;			SendMsg(&BlackMsg);			/*const char * pchar;			if(!strcmp(strsRec[1].c_str(),"DEL") )			{					BlacklistMsg.Handle = 0;			}			else if( !strcmp(strsRec[1].c_str(),"ADD") )			{				BlacklistMsg.Handle = 1;			}			{				TRACE_LOG("[_Debug]: we get a wrong Blacklist task !");				return FALSE;			}			pchar = strsRec[2].c_str();			while( NULL != pchar)			{				if('0' > *pchar || '9' < *pchar){					TRACE_LOG("[_Debug]: we get a wrong Blacklist task,it has non-numeric !");				}				pchar++;			}			memcpy(BlacklistMsg.Blacklist,strsRec[2].c_str(),strsRec[2].size());			BlacklistMsg.type = MSG_TYPE_RESPONSE_BLACKLIST;			BlacklistMsg.len = BLACKLIST_MSG_PARAM_LEN(strlen(BlacklistMsg.Blacklist));			if( NULL != m_pTaskExecute)			{				m_pTaskExecute->SendMsg(&BlacklistMsg);			}else			{				TRACE_LOG("[_Debug]: the TaskExecute interface agent not connect!");				return FALSE;			}*/		}		}	else if(MSG_TYPE_CHECK_TASK_STATUS == msg->type)	{		TRACE_LOG("[_Debug]: get return check task status");		if( 0 == ((TaskStatusMsg*)msg)->WorkStatus)		{			CreateWebTaskHandle( ((TaskStatusMsg*)msg)->InvokeID);		}	}	else if(MSG_TYPE_REQUEST_ALL_TASKS == msg->type)	{		ExecuteAllWebTasks();	}	else if(MSG_TYPE_TASK_STATUS == msg->type)	{		WriteStatus((TaskStatusMsg*)msg);	}	else if(MSG_TYPE_REQUEST_BLACKLIST == msg->type)	{		GetBlackList();	}	else if( MT_SESSION_CONNECT == msg->type )	{		TRACE_LOG("Session connected,    name = '%s'", ((TSessionConnect*)msg)->name);		if (strcmp(((TSessionConnect*)msg)->agent_name, ELEM_AGENT_WEB_INTERFACE_SERVER) == 0)		{			m_pWebInterface = ((TSessionConnect*)msg)->session;		}		else if (strcmp(((TSessionConnect*)msg)->agent_name, ELEM_AGENT_TASK_EXECUTE_CENTER) == 0)		{			m_pTaskExecute = ((TSessionConnect*)msg)->session;		}	}	else if( MT_SESSION_DISCONNECT == msg->type )	{		TRACE_LOG("Session disconnected,    name = '%s'", ((TSessionConnect*)msg)->name);		if (strcmp(((TSessionConnect*)msg)->agent_name, ELEM_AGENT_WEB_INTERFACE_SERVER) == 0)		{			m_pWebInterface = NULL;		}		else if (strcmp(((TSessionConnect*)msg)->agent_name, ELEM_AGENT_TASK_EXECUTE_CENTER) == 0)		{			m_pTaskExecute = NULL;		}	}	else	{		//CreateWebTaskHandle(51234996);		//ExecuteAllWebTasks();		/*		TaskStatusMsg TaskStatusMsg_test;		memset(&TaskStatusMsg_test,0,sizeof(TaskStatusMsg));		strcpy(TaskStatusMsg_test.InsertTime,"2015-11-25 13:13");		TaskStatusMsg_test.InvokeID = 51234996;		TaskStatusMsg_test.WorkStatus = 2;		WriteStatus(&TaskStatusMsg_test);		while(1);		*/		TRACE_LOG("Session incognizant,name = '%s'", ((TSessionConnect*)msg)->name);	}		return TRUE;}


BOOL CWebMsgReceiver::CreateWebTaskHandle(U64 TaskID){	I8 cQuery[CHAR_MAX_MYSQL_QUERY];	I8 buffer[CHAR_MAX_TASK_MSG_PACKAGES];		I8 command[64];	char cBuf[64];	char *pbuf=NULL;	FILE* fp;	strings strs,strsTime;	U32 wRowTotalNums,wRowID;	I32 iIsphone;	U64 iRegion;	U32 wSendObjectsNums;	string strHandlelObjects;	vector<char> HandleOjectsVector;	strHandlelObjects.clear();	memset(cQuery,0,CHAR_MAX_MYSQL_QUERY);	sprintf(cQuery,"select * from DC_RULE where RULENO = '%llu';",TaskID);	TRACE_LOG("[_Debug]: query:%s",cQuery);	m_MysqlOperate.SetQueryHandle(cQuery);	if( FALSE == m_MysqlOperate.GetMysqlData(&m_result) ){		TRACE_LOG("[_Error]: The Get Msyql query return FALSE,query is:%s",cQuery);		return FALSE;	}	if(0 == m_result.size())	{		TRACE_LOG("[_Error]: Not find the RuleID in Mysql !");		return FALSE;	}	memset(buffer,0,CHAR_MAX_TASK_MSG_PACKAGES);	m_pTaskPackageMsg = (TaskPackageMsg*)buffer;	m_pTaskPackageMsg->type = MSG_TYPE_TASK_ADD_DEL;	m_pTaskPackageMsg->InvokeID = atol(m_result[0][0].c_str());	m_pTaskPackageMsg->ExeFlag	= atoi(m_result[0][2].c_str());	memset(command,0,64);	sprintf(command,"date -d \"%s \" +%%s",m_result[0][4].c_str());	TRACE_LOG("[_Debug]: command:%s",command);	fp = popen(command,"r");	if(NULL == fp)	{		TRACE_LOG("[Error]: Action %s failure!",command);			return FALSE;	}	while(!feof(fp))	{		memset(cBuf,0,sizeof(cBuf));		if(NULL != fgets(cBuf,510,fp) )		{			//TRACE_LOG("after1 execute command result is:%s",cBuf);			if( ('0' > cBuf[0]) || ('9' < cBuf[0])){				continue;			}						pbuf = strtok(cBuf,"\n");			if(NULL != pbuf)			{				m_pTaskPackageMsg->Taskendtime = atoi(pbuf);			}		}	}	pclose(fp);	TRACE_LOG("[_Debug]: command execute success !");	m_pTaskPackageMsg->Isphone = atoi(m_result[0][6].c_str());	iIsphone = atoi(m_result[0][6].c_str());	iRegion = atol(m_result[0][7].c_str());	m_pTaskPackageMsg->Gathertype = atoi(m_result[0][8].c_str());	m_pTaskPackageMsg->Resulttype = atoi(m_result[0][9].c_str());	m_pTaskPackageMsg->Grade = atoi(m_result[0][10].c_str());		if( !strcmp(m_result[0][11].c_str(),m_result[0][12].c_str()) )	{		m_pTaskPackageMsg->Workstarttime = 0;		m_pTaskPackageMsg->Workstoptime = 24*3600;	}else	{		divide_string(m_result[0][11].c_str(),strsTime,":");		if( 2 > strsTime.size() ){			TRACE_LOG("[Error]: gather start time value in mysql do not conform to the rules !");			return FALSE;		}		m_pTaskPackageMsg->Workstarttime = atoi(strsTime.at(0).c_str())*3600 + atoi(strsTime.at(1).c_str())*60;		divide_string(m_result[0][12].c_str(),strsTime,":");		if( 2 > strsTime.size() ){			TRACE_LOG("[Error]: gather end time value in mysql do not conform to the rules !");			return FALSE;		}		m_pTaskPackageMsg->Workstoptime = atoi(strsTime.at(0).c_str())*3600 + atoi(strsTime.at(1).c_str())*60;	}	strcpy(m_pTaskPackageMsg->Filedirectory,m_result[0][13].c_str());	m_pTaskPackageMsg->Filefrequence = atoi(m_result[0][14].c_str());		if( 3 == m_pTaskPackageMsg->ExeFlag )	{		m_pTaskPackageMsg->ExeFlag = 1;	}else	{		m_pTaskPackageMsg->ExeFlag = 0;	}	if( 1 == iIsphone )//get phone numbers	{		memset(cQuery,0,CHAR_MAX_MYSQL_QUERY);		sprintf(cQuery,"select * from DC_PHONE where RULENO = '%llu';",TaskID);		m_MysqlOperate.SetQueryHandle(cQuery);		if( FALSE == m_MysqlOperate.GetMysqlData(&m_result) ){			TRACE_LOG("[_Error]: The Get Msyql query return FALSE,query is:%s",cQuery);			return FALSE;		}		wRowTotalNums = m_result.size();				if(0 == wRowTotalNums)		{			TRACE_LOG("[error]: Isphone=1. Mysql has not phones !");			return FALSE;		}			wRowID = 0;		strHandlelObjects.append("M;");		while(wRowTotalNums > wRowID)		{				strHandlelObjects.append(m_result[wRowID++][1].c_str());			strHandlelObjects.append(";");		}			strHandlelObjects.append("_M");		TRACE_LOG("[_Debug]: Task handle objects:%s",strHandlelObjects.c_str());	}		if( 0 != iRegion )//get the regions	{		memset(cQuery,0,CHAR_MAX_MYSQL_QUERY);		sprintf(cQuery,"select * from DC_REGIONCELL where REGIONNO = '%llu';",iRegion);		TRACE_LOG("[_Debug]: query:%s",cQuery);		m_MysqlOperate.SetQueryHandle(cQuery);		if( FALSE == m_MysqlOperate.GetMysqlData(&m_result) ){			TRACE_LOG("[_Error]: The Get Msyql query return FALSE,query is:%s",cQuery);			return FALSE;		}		wRowTotalNums = m_result.size();		if( 0 == wRowTotalNums )		{			TRACE_LOG("[error]: Mysql has not region !");			return FALSE;			}		wRowID = 0;		strHandlelObjects.append("C;");		while( wRowTotalNums > wRowID )		{				strHandlelObjects.append(m_result[wRowID][1].c_str());			strHandlelObjects.append(",");			strHandlelObjects.append(m_result[wRowID++][2].c_str());			strHandlelObjects.append(";");		}			strHandlelObjects.append("_C");	}	//get user-defined rule	memset(cQuery,0,CHAR_MAX_MYSQL_QUERY);	sprintf(cQuery,"select * from DC_DEFRULE where RULENO = '%llu';",TaskID);	TRACE_DEBUG("[_Debug]: query:%s",cQuery);	m_MysqlOperate.SetQueryHandle(cQuery);	if( FALSE == m_MysqlOperate.GetMysqlData(&m_result) ){		TRACE_LOG("[_Error]: The Get Msyql query return FALSE,query is:%s",cQuery);		return FALSE;	}	wRowTotalNums = m_result.size();	if( 0 < wRowTotalNums )	{		m_pTaskPackageMsg->TaskRule.IsEncrypt = atoi(m_result[0][1].c_str());		m_pTaskPackageMsg->TaskRule.Type = atoi(m_result[0][2].c_str());		strcpy(m_pTaskPackageMsg->TaskRule.Recolum,m_result[0][3].c_str());		strcpy(m_pTaskPackageMsg->TaskRule.AESColum,m_result[0][4].c_str());		strcpy(m_pTaskPackageMsg->TaskRule.StartPostion,m_result[0][5].c_str());		strcpy(m_pTaskPackageMsg->TaskRule.EndPostion,m_result[0][6].c_str());		strcpy(m_pTaskPackageMsg->TaskRule.To,m_result[0][7].c_str());		strcpy(m_pTaskPackageMsg->TaskRule.Fetch,m_result[0][8].c_str());		strcpy(m_pTaskPackageMsg->TaskRule.Filter,m_result[0][9].c_str());	}	//judge the TaskType of TaskpackageMsg ***********************************************************//´ý´¦Àí	TRACE_LOG("[_Debug]: the defrule result:isEncrypt:%d;Type:%d;Recolum:%s;AESColum:%s;StartPostion:%s;\EndPostion:%s;To:%s;Fetch:%s;Filter:%s",m_pTaskPackageMsg->TaskRule.IsEncrypt,m_pTaskPackageMsg->TaskRule.Type,	m_pTaskPackageMsg->TaskRule.Recolum,m_pTaskPackageMsg->TaskRule.AESColum,m_pTaskPackageMsg->TaskRule.StartPostion,	m_pTaskPackageMsg->TaskRule.EndPostion,m_pTaskPackageMsg->TaskRule.To,m_pTaskPackageMsg->TaskRule.Fetch,	m_pTaskPackageMsg->TaskRule.Filter);		TRACE_LOG("[_Debug]: sizeof(TaskPackageMsg)=%d;strHandlelObjects.size()=%d",sizeof(TaskPackageMsg),strHandlelObjects.size());SENDWEBTASKPACKAGE:	if( CHAR_MAX_TASK_MSG_PACKAGE - sizeof(TaskPackageMsg) < strHandlelObjects.size() )	{		m_pTaskPackageMsg->PackageOverFlag = 0;		wSendObjectsNums = CHAR_MAX_TASK_MSG_PACKAGE - sizeof(TaskPackageMsg);	}else	{		m_pTaskPackageMsg->PackageOverFlag = 1;		wSendObjectsNums = strHandlelObjects.size();	}		memset(m_pTaskPackageMsg->OperateObjects,0,wSendObjectsNums);	memcpy(m_pTaskPackageMsg->OperateObjects,strHandlelObjects.c_str(),wSendObjectsNums);	m_pTaskPackageMsg->len = sizeof(TaskPackageMsg) + strlen(m_pTaskPackageMsg->OperateObjects) - sizeof(TRawMsg)+1;	TRACE_LOG("[DEBUG]: m_pTaskPackageMsg PackageOverFlag=%u,ExeFlag=%u,InvokeID=%llu,Workstarttime=%u,Workstoptime=%u,\Taskendtime=%u,Isphone=%u,Gathertype=%u,Gather=%u,Resulttype=%u,Filefrequence=%u,Filedirectory=%s,len=%d,strlen(m_pTaskPackageMsg->OperateObjects)=%d",		m_pTaskPackageMsg->PackageOverFlag,m_pTaskPackageMsg->ExeFlag,m_pTaskPackageMsg->InvokeID,m_pTaskPackageMsg->Workstarttime,		m_pTaskPackageMsg->Workstoptime,m_pTaskPackageMsg->Taskendtime,m_pTaskPackageMsg->Isphone,		m_pTaskPackageMsg->Gathertype,m_pTaskPackageMsg->Resulttype,m_pTaskPackageMsg->Gathertype,		m_pTaskPackageMsg->Filefrequence,m_pTaskPackageMsg->Filedirectory,m_pTaskPackageMsg->len,strlen(m_pTaskPackageMsg->OperateObjects));	printf("[_Debug]: m_pTaskPackageMsg OperateObjects=%s\n",m_pTaskPackageMsg->OperateObjects);			if(NULL != m_pTaskExecute)	{		TRACE_LOG("[_Debug]: send Task Msg !");		m_pTaskExecute->SendMsg(m_pTaskPackageMsg);	}else	{		TRACE_LOG("[_Warning]: the TaskExecute interface agent not connect! ");		return FALSE;	}	if( CHAR_MAX_TASK_MSG_PACKAGE - sizeof(TaskPackageMsg) == wSendObjectsNums)	{		strHandlelObjects.erase(0,wSendObjectsNums);		goto SENDWEBTASKPACKAGE;	}	return TRUE;}BOOL CWebMsgReceiver::ExecuteAllWebTasks(){	char cTask[32];	char buffer[1024];	U32 wRowTotalNums,wRowID;	TRawMsg *WebTaskMsg = (TRawMsg *)buffer;	m_MysqlOperate.SetQueryHandle("select * from DC_RULE where RULLSTATUS = '1';");//task runing now	if( FALSE == m_MysqlOperate.GetMysqlData(&m_result) ){		TRACE_LOG("[_Error]: The Get Msyql query return FALSE,query is:select * from DC_RULE where RULLSTATUS = '1';");		return FALSE;	}	wRowTotalNums = m_result.size();	if( 0 == wRowTotalNums )	{		TRACE_LOG("[error]: Mysql has not region !");			return FALSE;	}	wRowID = 0;	while( wRowTotalNums > wRowID )	{			memset(cTask,0,32);		sprintf(cTask,"RULENO,%s,CREATE",m_result[wRowID++][0].c_str());		memset(buffer,0,1024);		WebTaskMsg->type = MSG_TYPE_WEB_TASK;		WebTaskMsg->len = strlen(cTask);		memcpy(WebTaskMsg+sizeof(TRawMsg),cTask,strlen(cTask));		//TRACE_LOG("[DEBUG]: All task is:%s",cTask);		g_WebMsgReceiverThread.SendMsg(WebTaskMsg);	}	}BOOL CWebMsgReceiver::CloseWebTaskHandle(U64 TaskID){	TaskPackageMsg PackageMsg;	memset(&PackageMsg,0,sizeof(TaskPackageMsg));	PackageMsg.InvokeID = TaskID;	PackageMsg.ExeFlag = 0;	PackageMsg.len = sizeof(TaskPackageMsg);	PackageMsg.type = MSG_TYPE_TASK_ADD_DEL;	if( NULL != m_pTaskExecute)	{TRACE_LOG("[_Debug]: Send CLOSE_MSG to TaskExecute interface agent!");		m_pTaskExecute->SendMsg(&PackageMsg);	}else	{		TRACE_LOG("[_Warning]: the TaskExecute interface agent not connect!");		return FALSE;	}	return TRUE;}

BOOL CWebMsgReceiver::WriteStatus(TaskStatusMsg* msg){	char buffer[1024];	char cQuery[CHAR_MAX_MYSQL_QUERY];		memset(cQuery,0,CHAR_MAX_MYSQL_QUERY);	sprintf(cQuery,"INSERT INTO DC_APPSTATUS VALUES('%llu','%u','%s','NULL');",msg->InvokeID,msg->WorkStatus,msg->InsertTime);	//TRACE_LOG("[DEBUG]: query:%s",cQuery);	m_MysqlOperate.SetQueryHandle(cQuery);	m_MysqlOperate.InsertIntoMysqlData();	return TRUE;}
BOOL CWebMsgReceiver::GetBlackList(){	char buffer[1024];	U32 wRowTotalNums,wRowID;	U32 wSendChars;	string strBlacklist;	BlacklistTaskMsg *BlackListMsg = (BlacklistTaskMsg*)buffer;		m_MysqlOperate.SetQueryHandle("select * from DC_BLACK;");//get blacklist 	if( FALSE == m_MysqlOperate.GetMysqlData(&m_result) ){		TRACE_LOG("[_Error]: The Get Msyql query return FALSE,query is:select * from DC_BLACK;");		return FALSE;	}	wRowTotalNums = m_result.size();	if(0 == wRowTotalNums)	{		return FALSE;		TRACE_LOG("[error]:Mysql has not Blacklist !");	}		wRowID = 0;	strBlacklist.clear();	while(wRowTotalNums > wRowID)	{			strBlacklist.append(m_result[wRowID++][1].c_str());		strBlacklist.append(";");	}SENDBLACKLIST:	wSendChars = strBlacklist.size();	if(1000 < wSendChars)	{		wSendChars = 1000;			}	memset(buffer,0,sizeof(1024));	BlackListMsg->type = MSG_TYPE_RESPONSE_BLACKLIST;	BlackListMsg->len = wSendChars + sizeof(BlacklistTaskMsg) - sizeof(TRawMsg);	BlackListMsg->Handle = 1;	memcpy(BlackListMsg->Blacklist,strBlacklist.c_str(),wSendChars);	if( NULL != m_pTaskExecute)	{		m_pTaskExecute->SendMsg((TRawMsg*)BlackListMsg);//	}else	{		TRACE_LOG("the TaskExecute interface agent not connect!");		return FALSE;	}	if(1000 == wSendChars)	{		strBlacklist.erase(0,wSendChars);		goto SENDBLACKLIST;	}		return TRUE;}
































